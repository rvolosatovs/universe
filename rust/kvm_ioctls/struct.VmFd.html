<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Wrapper over KVM VM ioctls."><meta name="keywords" content="rust, rustlang, rust-lang, VmFd"><title>VmFd in kvm_ioctls - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../ayu.css" disabled><link rel="stylesheet" type="text/css" href="../dark.css" disabled><link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../storage.js"></script><script src="../crates.js"></script><script defer src="../main.js"></script>
    <noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../favicon.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../kvm_ioctls/index.html"><div class="logo-container"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"></h2>
    </nav>
    <nav class="sidebar"><a class="sidebar-logo" href="../kvm_ioctls/index.html"><div class="logo-container"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></div>
        </a><h2 class="location"><a href="#">VmFd</a></h2><div class="sidebar-elems"><section><div class="block"><h3 class="sidebar-title"><a href="#implementations">Methods</a></h3><ul><li><a href="#method.check_extension">check_extension</a></li><li><a href="#method.create_device">create_device</a></li><li><a href="#method.create_irq_chip">create_irq_chip</a></li><li><a href="#method.create_pit2">create_pit2</a></li><li><a href="#method.create_vcpu">create_vcpu</a></li><li><a href="#method.create_vcpu_from_rawfd">create_vcpu_from_rawfd</a></li><li><a href="#method.enable_cap">enable_cap</a></li><li><a href="#method.encrypt_op">encrypt_op</a></li><li><a href="#method.encrypt_op_sev">encrypt_op_sev</a></li><li><a href="#method.get_clock">get_clock</a></li><li><a href="#method.get_dirty_log">get_dirty_log</a></li><li><a href="#method.get_irqchip">get_irqchip</a></li><li><a href="#method.get_pit2">get_pit2</a></li><li><a href="#method.register_enc_memory_region">register_enc_memory_region</a></li><li><a href="#method.register_ioevent">register_ioevent</a></li><li><a href="#method.register_irqfd">register_irqfd</a></li><li><a href="#method.register_irqfd_with_resample">register_irqfd_with_resample</a></li><li><a href="#method.run_size">run_size</a></li><li><a href="#method.set_clock">set_clock</a></li><li><a href="#method.set_gsi_routing">set_gsi_routing</a></li><li><a href="#method.set_identity_map_address">set_identity_map_address</a></li><li><a href="#method.set_irq_line">set_irq_line</a></li><li><a href="#method.set_irqchip">set_irqchip</a></li><li><a href="#method.set_pit2">set_pit2</a></li><li><a href="#method.set_tss_address">set_tss_address</a></li><li><a href="#method.set_user_memory_region">set_user_memory_region</a></li><li><a href="#method.signal_msi">signal_msi</a></li><li><a href="#method.unregister_enc_memory_region">unregister_enc_memory_region</a></li><li><a href="#method.unregister_ioevent">unregister_ioevent</a></li><li><a href="#method.unregister_irqfd">unregister_irqfd</a></li></ul></div><div class="block"><h3 class="sidebar-title"><a href="#trait-implementations">Trait Implementations</a></h3><ul><li><a href="#impl-AsRawFd">AsRawFd</a></li><li><a href="#impl-Debug">Debug</a></li></ul></div><div class="block"><h3 class="sidebar-title"><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul><li><a href="#impl-RefUnwindSafe">RefUnwindSafe</a></li><li><a href="#impl-Send">Send</a></li><li><a href="#impl-Sync">Sync</a></li><li><a href="#impl-Unpin">Unpin</a></li><li><a href="#impl-UnwindSafe">UnwindSafe</a></li></ul></div><div class="block"><h3 class="sidebar-title"><a href="#blanket-implementations">Blanket Implementations</a></h3><ul><li><a href="#impl-Any">Any</a></li><li><a href="#impl-Borrow%3CT%3E">Borrow&lt;T&gt;</a></li><li><a href="#impl-BorrowMut%3CT%3E">BorrowMut&lt;T&gt;</a></li><li><a href="#impl-From%3CT%3E">From&lt;T&gt;</a></li><li><a href="#impl-Into%3CU%3E">Into&lt;U&gt;</a></li><li><a href="#impl-TryFrom%3CU%3E">TryFrom&lt;U&gt;</a></li><li><a href="#impl-TryInto%3CU%3E">TryInto&lt;U&gt;</a></li></ul></div></section><h2 class="location"><a href="index.html">In kvm_ioctls</a></h2><div id="sidebar-vars" data-name="VmFd" data-ty="struct" data-relpath=""></div><script defer src="sidebar-items.js"></script></div></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../kvm_ioctls/index.html"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></a><nav class="sub"><div class="theme-picker hidden"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="22" height="22" alt="Pick another theme!" src="../brush.svg"></button><div id="theme-choices" role="menu"></div></div><form class="search-form"><div class="search-container"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../wheel.svg"></a></div></form></nav></div><section id="main-content" class="content"><div class="main-heading">
    <h1 class="fqn"><span class="in-band">Struct <a href="index.html">kvm_ioctls</a>::<wbr><a class="struct" href="#">VmFd</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span></h1><span class="out-of-band"><a class="srclink" href="../src/kvm_ioctls/ioctls/vm.rs.html#55-58">source</a> · <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span></div><div class="docblock item-decl"><pre class="rust struct"><code>pub struct VmFd { /* private fields */ }</code></pre></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Wrapper over KVM VM ioctls.</p>
</div></details><h2 id="implementations" class="small-section-header">Implementations<a href="#implementations" class="anchor"></a></h2><div id="implementations-list"><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../src/kvm_ioctls/ioctls/vm.rs.html#60-1573">source</a></span><a href="#impl" class="anchor"></a><h3 class="code-header in-band">impl <a class="struct" href="struct.VmFd.html" title="struct kvm_ioctls::VmFd">VmFd</a></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.set_user_memory_region" class="method has-srclink"><span class="rightside"><a class="srclink" href="../src/kvm_ioctls/ioctls/vm.rs.html#102-112">source</a></span><a href="#method.set_user_memory_region" class="anchor"></a><h4 class="code-header">pub unsafe fn <a href="#method.set_user_memory_region" class="fnname">set_user_memory_region</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;user_memory_region: <a class="struct" href="../kvm_bindings/x86/bindings/struct.kvm_userspace_memory_region.html" title="struct kvm_bindings::x86::bindings::kvm_userspace_memory_region">kvm_userspace_memory_region</a><br>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>, <a class="struct" href="struct.Error.html" title="struct kvm_ioctls::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Creates/modifies a guest physical memory slot.</p>
<p>See the documentation for <code>KVM_SET_USER_MEMORY_REGION</code>.</p>
<h5 id="arguments"><a href="#arguments">Arguments</a></h5>
<ul>
<li><code>user_memory_region</code> - Guest physical memory slot. For details check the
<code>kvm_userspace_memory_region</code> structure in the
<a href="https://www.kernel.org/doc/Documentation/virtual/kvm/api.txt">KVM API doc</a>.</li>
</ul>
<h5 id="safety"><a href="#safety">Safety</a></h5>
<p>This function is unsafe because there is no guarantee <code>userspace_addr</code> points to a valid
memory region, nor the memory region lives as long as the kernel needs it to.</p>
<p>The caller of this method must make sure that:</p>
<ul>
<li>the raw pointer (<code>userspace_addr</code>) points to valid memory</li>
<li>the regions provided to KVM are not overlapping other memory regions.</li>
</ul>
<h5 id="example"><a href="#example">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">kvm_bindings</span>;

<span class="kw">use</span> <span class="ident">kvm_bindings::kvm_userspace_memory_region</span>;
<span class="kw">use</span> <span class="ident">kvm_ioctls::Kvm</span>;

<span class="kw">let</span> <span class="ident">kvm</span> <span class="op">=</span> <span class="ident">Kvm::new</span>().<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">vm</span> <span class="op">=</span> <span class="ident">kvm</span>.<span class="ident">create_vm</span>().<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">mem_region</span> <span class="op">=</span> <span class="ident">kvm_userspace_memory_region</span> {
    <span class="ident">slot</span>: <span class="number">0</span>,
    <span class="ident">guest_phys_addr</span>: <span class="number">0x10000</span> <span class="kw">as</span> <span class="ident">u64</span>,
    <span class="ident">memory_size</span>: <span class="number">0x10000</span> <span class="kw">as</span> <span class="ident">u64</span>,
    <span class="ident">userspace_addr</span>: <span class="number">0x0</span> <span class="kw">as</span> <span class="ident">u64</span>,
    <span class="ident">flags</span>: <span class="number">0</span>,
};
<span class="kw">unsafe</span> {
    <span class="ident">vm</span>.<span class="ident">set_user_memory_region</span>(<span class="ident">mem_region</span>).<span class="ident">unwrap</span>();
};</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.set_tss_address" class="method has-srclink"><span class="rightside"><a class="srclink" href="../src/kvm_ioctls/ioctls/vm.rs.html#132-140">source</a></span><a href="#method.set_tss_address" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.set_tss_address" class="fnname">set_tss_address</a>(&amp;self, offset: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>, <a class="struct" href="struct.Error.html" title="struct kvm_ioctls::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Sets the address of the three-page region in the VM’s address space.</p>
<p>See the documentation for <code>KVM_SET_TSS_ADDR</code>.</p>
<h5 id="arguments-1"><a href="#arguments-1">Arguments</a></h5>
<ul>
<li><code>offset</code> - Physical address of a three-page region in the guest’s physical address space.</li>
</ul>
<h5 id="example-1"><a href="#example-1">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">kvm</span> <span class="op">=</span> <span class="ident">Kvm::new</span>().<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">vm</span> <span class="op">=</span> <span class="ident">kvm</span>.<span class="ident">create_vm</span>().<span class="ident">unwrap</span>();
<span class="ident">vm</span>.<span class="ident">set_tss_address</span>(<span class="number">0xfffb_d000</span>).<span class="ident">unwrap</span>();</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.set_identity_map_address" class="method has-srclink"><span class="rightside"><a class="srclink" href="../src/kvm_ioctls/ioctls/vm.rs.html#160-168">source</a></span><a href="#method.set_identity_map_address" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.set_identity_map_address" class="fnname">set_identity_map_address</a>(&amp;self, address: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u64.html">u64</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>, <a class="struct" href="struct.Error.html" title="struct kvm_ioctls::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Sets the address of the one-page region in the VM’s address space.</p>
<p>See the documentation for <code>KVM_SET_IDENTITY_MAP_ADDR</code>.</p>
<h5 id="arguments-2"><a href="#arguments-2">Arguments</a></h5>
<ul>
<li><code>address</code> - Physical address of a one-page region in the guest’s physical address space.</li>
</ul>
<h5 id="example-2"><a href="#example-2">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">kvm</span> <span class="op">=</span> <span class="ident">Kvm::new</span>().<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">vm</span> <span class="op">=</span> <span class="ident">kvm</span>.<span class="ident">create_vm</span>().<span class="ident">unwrap</span>();
<span class="ident">vm</span>.<span class="ident">set_identity_map_address</span>(<span class="number">0xfffb_c000</span>).<span class="ident">unwrap</span>();</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.create_irq_chip" class="method has-srclink"><span class="rightside"><a class="srclink" href="../src/kvm_ioctls/ioctls/vm.rs.html#206-214">source</a></span><a href="#method.create_irq_chip" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.create_irq_chip" class="fnname">create_irq_chip</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>, <a class="struct" href="struct.Error.html" title="struct kvm_ioctls::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Creates an in-kernel interrupt controller.</p>
<p>See the documentation for <code>KVM_CREATE_IRQCHIP</code>.</p>
<h5 id="example-3"><a href="#example-3">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">kvm</span> <span class="op">=</span> <span class="ident">Kvm::new</span>().<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">vm</span> <span class="op">=</span> <span class="ident">kvm</span>.<span class="ident">create_vm</span>().<span class="ident">unwrap</span>();

<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">any</span>(<span class="ident">target_arch</span> <span class="op">=</span> <span class="string">&quot;x86&quot;</span>, <span class="ident">target_arch</span> <span class="op">=</span> <span class="string">&quot;x86_64&quot;</span>))]</span>
<span class="ident">vm</span>.<span class="ident">create_irq_chip</span>().<span class="ident">unwrap</span>();
<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">any</span>(<span class="ident">target_arch</span> <span class="op">=</span> <span class="string">&quot;arm&quot;</span>, <span class="ident">target_arch</span> <span class="op">=</span> <span class="string">&quot;aarch64&quot;</span>))]</span>
{
    <span class="kw">use</span> <span class="ident">kvm_bindings</span>::{
        <span class="ident">kvm_create_device</span>, <span class="ident">kvm_device_type_KVM_DEV_TYPE_ARM_VGIC_V2</span>, <span class="ident">KVM_CREATE_DEVICE_TEST</span>,
    };
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">gic_device</span> <span class="op">=</span> <span class="ident">kvm_bindings::kvm_create_device</span> {
        <span class="ident">type_</span>: <span class="ident">kvm_device_type_KVM_DEV_TYPE_ARM_VGIC_V2</span>,
        <span class="ident">fd</span>: <span class="number">0</span>,
        <span class="ident">flags</span>: <span class="ident">KVM_CREATE_DEVICE_TEST</span>,
    };
    <span class="kw">if</span> <span class="ident">vm</span>.<span class="ident">create_device</span>(<span class="kw-2">&amp;mut</span> <span class="ident">gic_device</span>).<span class="ident">is_ok</span>() {
        <span class="ident">vm</span>.<span class="ident">create_irq_chip</span>().<span class="ident">unwrap</span>();
    }
}</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.get_irqchip" class="method has-srclink"><span class="rightside"><a class="srclink" href="../src/kvm_ioctls/ioctls/vm.rs.html#241-251">source</a></span><a href="#method.get_irqchip" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.get_irqchip" class="fnname">get_irqchip</a>(&amp;self, irqchip: &amp;mut <a class="struct" href="../kvm_bindings/x86/bindings/struct.kvm_irqchip.html" title="struct kvm_bindings::x86::bindings::kvm_irqchip">kvm_irqchip</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>, <a class="struct" href="struct.Error.html" title="struct kvm_ioctls::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>X86 specific call to retrieve the state of a kernel interrupt controller.</p>
<p>See the documentation for <code>KVM_GET_IRQCHIP</code> in the
<a href="https://www.kernel.org/doc/Documentation/virtual/kvm/api.txt">KVM API doc</a>.</p>
<h5 id="arguments-3"><a href="#arguments-3">Arguments</a></h5>
<ul>
<li><code>irqchip</code> - <code>kvm_irqchip</code> (input/output) to be read.</li>
</ul>
<h5 id="example-4"><a href="#example-4">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">kvm</span> <span class="op">=</span> <span class="ident">Kvm::new</span>().<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">vm</span> <span class="op">=</span> <span class="ident">kvm</span>.<span class="ident">create_vm</span>().<span class="ident">unwrap</span>();

<span class="ident">vm</span>.<span class="ident">create_irq_chip</span>().<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">irqchip</span> <span class="op">=</span> <span class="ident">kvm_irqchip::default</span>();
<span class="ident">irqchip</span>.<span class="ident">chip_id</span> <span class="op">=</span> <span class="ident">KVM_IRQCHIP_PIC_MASTER</span>;
<span class="ident">vm</span>.<span class="ident">get_irqchip</span>(<span class="kw-2">&amp;mut</span> <span class="ident">irqchip</span>).<span class="ident">unwrap</span>();</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.set_irqchip" class="method has-srclink"><span class="rightside"><a class="srclink" href="../src/kvm_ioctls/ioctls/vm.rs.html#279-289">source</a></span><a href="#method.set_irqchip" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.set_irqchip" class="fnname">set_irqchip</a>(&amp;self, irqchip: &amp;<a class="struct" href="../kvm_bindings/x86/bindings/struct.kvm_irqchip.html" title="struct kvm_bindings::x86::bindings::kvm_irqchip">kvm_irqchip</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>, <a class="struct" href="struct.Error.html" title="struct kvm_ioctls::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>X86 specific call to set the state of a kernel interrupt controller.</p>
<p>See the documentation for <code>KVM_SET_IRQCHIP</code> in the
<a href="https://www.kernel.org/doc/Documentation/virtual/kvm/api.txt">KVM API doc</a>.</p>
<h5 id="arguments-4"><a href="#arguments-4">Arguments</a></h5>
<ul>
<li><code>irqchip</code> - <code>kvm_irqchip</code> (input/output) to be written.</li>
</ul>
<h5 id="example-5"><a href="#example-5">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">kvm</span> <span class="op">=</span> <span class="ident">Kvm::new</span>().<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">vm</span> <span class="op">=</span> <span class="ident">kvm</span>.<span class="ident">create_vm</span>().<span class="ident">unwrap</span>();

<span class="ident">vm</span>.<span class="ident">create_irq_chip</span>().<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">irqchip</span> <span class="op">=</span> <span class="ident">kvm_irqchip::default</span>();
<span class="ident">irqchip</span>.<span class="ident">chip_id</span> <span class="op">=</span> <span class="ident">KVM_IRQCHIP_PIC_MASTER</span>;
<span class="comment">// Your `irqchip` manipulation here.</span>
<span class="ident">vm</span>.<span class="ident">set_irqchip</span>(<span class="kw-2">&amp;mut</span> <span class="ident">irqchip</span>).<span class="ident">unwrap</span>();</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.create_pit2" class="method has-srclink"><span class="rightside"><a class="srclink" href="../src/kvm_ioctls/ioctls/vm.rs.html#311-320">source</a></span><a href="#method.create_pit2" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.create_pit2" class="fnname">create_pit2</a>(&amp;self, pit_config: <a class="struct" href="../kvm_bindings/x86/bindings/struct.kvm_pit_config.html" title="struct kvm_bindings::x86::bindings::kvm_pit_config">kvm_pit_config</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>, <a class="struct" href="struct.Error.html" title="struct kvm_ioctls::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Creates a PIT as per the <code>KVM_CREATE_PIT2</code> ioctl.</p>
<h5 id="arguments-5"><a href="#arguments-5">Arguments</a></h5>
<ul>
<li>pit_config - PIT configuration. For details check the <code>kvm_pit_config</code> structure in the
<a href="https://www.kernel.org/doc/Documentation/virtual/kvm/api.txt">KVM API doc</a>.</li>
</ul>
<h5 id="example-6"><a href="#example-6">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">kvm_bindings</span>;
<span class="kw">use</span> <span class="ident">kvm_bindings::kvm_pit_config</span>;

<span class="kw">let</span> <span class="ident">kvm</span> <span class="op">=</span> <span class="ident">Kvm::new</span>().<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">vm</span> <span class="op">=</span> <span class="ident">kvm</span>.<span class="ident">create_vm</span>().<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">pit_config</span> <span class="op">=</span> <span class="ident">kvm_pit_config::default</span>();
<span class="ident">vm</span>.<span class="ident">create_pit2</span>(<span class="ident">pit_config</span>).<span class="ident">unwrap</span>();</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.get_pit2" class="method has-srclink"><span class="rightside"><a class="srclink" href="../src/kvm_ioctls/ioctls/vm.rs.html#346-357">source</a></span><a href="#method.get_pit2" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.get_pit2" class="fnname">get_pit2</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../kvm_bindings/x86/bindings/struct.kvm_pit_state2.html" title="struct kvm_bindings::x86::bindings::kvm_pit_state2">kvm_pit_state2</a>, <a class="struct" href="struct.Error.html" title="struct kvm_ioctls::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>X86 specific call to retrieve the state of the in-kernel PIT model.</p>
<p>See the documentation for <code>KVM_GET_PIT2</code> in the
<a href="https://www.kernel.org/doc/Documentation/virtual/kvm/api.txt">KVM API doc</a>.</p>
<h5 id="arguments-6"><a href="#arguments-6">Arguments</a></h5>
<ul>
<li><code>pitstate</code> - <code>kvm_pit_state2</code> to be read.</li>
</ul>
<h5 id="example-7"><a href="#example-7">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">kvm</span> <span class="op">=</span> <span class="ident">Kvm::new</span>().<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">vm</span> <span class="op">=</span> <span class="ident">kvm</span>.<span class="ident">create_vm</span>().<span class="ident">unwrap</span>();

<span class="kw">let</span> <span class="ident">pit_config</span> <span class="op">=</span> <span class="ident">kvm_pit_config::default</span>();
<span class="ident">vm</span>.<span class="ident">create_pit2</span>(<span class="ident">pit_config</span>).<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">pitstate</span> <span class="op">=</span> <span class="ident">vm</span>.<span class="ident">get_pit2</span>().<span class="ident">unwrap</span>();</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.set_pit2" class="method has-srclink"><span class="rightside"><a class="srclink" href="../src/kvm_ioctls/ioctls/vm.rs.html#385-395">source</a></span><a href="#method.set_pit2" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.set_pit2" class="fnname">set_pit2</a>(&amp;self, pitstate: &amp;<a class="struct" href="../kvm_bindings/x86/bindings/struct.kvm_pit_state2.html" title="struct kvm_bindings::x86::bindings::kvm_pit_state2">kvm_pit_state2</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>, <a class="struct" href="struct.Error.html" title="struct kvm_ioctls::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>X86 specific call to set the state of the in-kernel PIT model.</p>
<p>See the documentation for <code>KVM_SET_PIT2</code> in the
<a href="https://www.kernel.org/doc/Documentation/virtual/kvm/api.txt">KVM API doc</a>.</p>
<h5 id="arguments-7"><a href="#arguments-7">Arguments</a></h5>
<ul>
<li><code>pitstate</code> - <code>kvm_pit_state2</code> to be written.</li>
</ul>
<h5 id="example-8"><a href="#example-8">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">kvm</span> <span class="op">=</span> <span class="ident">Kvm::new</span>().<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">vm</span> <span class="op">=</span> <span class="ident">kvm</span>.<span class="ident">create_vm</span>().<span class="ident">unwrap</span>();

<span class="kw">let</span> <span class="ident">pit_config</span> <span class="op">=</span> <span class="ident">kvm_pit_config::default</span>();
<span class="ident">vm</span>.<span class="ident">create_pit2</span>(<span class="ident">pit_config</span>).<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">pitstate</span> <span class="op">=</span> <span class="ident">kvm_pit_state2::default</span>();
<span class="comment">// Your `pitstate` manipulation here.</span>
<span class="ident">vm</span>.<span class="ident">set_pit2</span>(<span class="kw-2">&amp;mut</span> <span class="ident">pitstate</span>).<span class="ident">unwrap</span>();</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.get_clock" class="method has-srclink"><span class="rightside"><a class="srclink" href="../src/kvm_ioctls/ioctls/vm.rs.html#416-427">source</a></span><a href="#method.get_clock" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.get_clock" class="fnname">get_clock</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="../kvm_bindings/x86/bindings/struct.kvm_clock_data.html" title="struct kvm_bindings::x86::bindings::kvm_clock_data">kvm_clock_data</a>, <a class="struct" href="struct.Error.html" title="struct kvm_ioctls::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>X86 specific call to retrieve the current timestamp of kvmclock.</p>
<p>See the documentation for <code>KVM_GET_CLOCK</code> in the
<a href="https://www.kernel.org/doc/Documentation/virtual/kvm/api.txt">KVM API doc</a>.</p>
<h5 id="arguments-8"><a href="#arguments-8">Arguments</a></h5>
<ul>
<li><code>clock</code> - <code>kvm_clock_data</code> to be read.</li>
</ul>
<h5 id="example-9"><a href="#example-9">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">kvm</span> <span class="op">=</span> <span class="ident">Kvm::new</span>().<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">vm</span> <span class="op">=</span> <span class="ident">kvm</span>.<span class="ident">create_vm</span>().<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">clock</span> <span class="op">=</span> <span class="ident">vm</span>.<span class="ident">get_clock</span>().<span class="ident">unwrap</span>();</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.set_clock" class="method has-srclink"><span class="rightside"><a class="srclink" href="../src/kvm_ioctls/ioctls/vm.rs.html#451-461">source</a></span><a href="#method.set_clock" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.set_clock" class="fnname">set_clock</a>(&amp;self, clock: &amp;<a class="struct" href="../kvm_bindings/x86/bindings/struct.kvm_clock_data.html" title="struct kvm_bindings::x86::bindings::kvm_clock_data">kvm_clock_data</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>, <a class="struct" href="struct.Error.html" title="struct kvm_ioctls::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>X86 specific call to set the current timestamp of kvmclock.</p>
<p>See the documentation for <code>KVM_SET_CLOCK</code> in the
<a href="https://www.kernel.org/doc/Documentation/virtual/kvm/api.txt">KVM API doc</a>.</p>
<h5 id="arguments-9"><a href="#arguments-9">Arguments</a></h5>
<ul>
<li><code>clock</code> - <code>kvm_clock_data</code> to be written.</li>
</ul>
<h5 id="example-10"><a href="#example-10">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">kvm</span> <span class="op">=</span> <span class="ident">Kvm::new</span>().<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">vm</span> <span class="op">=</span> <span class="ident">kvm</span>.<span class="ident">create_vm</span>().<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">clock</span> <span class="op">=</span> <span class="ident">kvm_clock_data::default</span>();
<span class="ident">vm</span>.<span class="ident">set_clock</span>(<span class="kw-2">&amp;mut</span> <span class="ident">clock</span>).<span class="ident">unwrap</span>();</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.signal_msi" class="method has-srclink"><span class="rightside"><a class="srclink" href="../src/kvm_ioctls/ioctls/vm.rs.html#503-512">source</a></span><a href="#method.signal_msi" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.signal_msi" class="fnname">signal_msi</a>(&amp;self, msi: <a class="struct" href="../kvm_bindings/x86/bindings/struct.kvm_msi.html" title="struct kvm_bindings::x86::bindings::kvm_msi">kvm_msi</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="type" href="https://doc.rust-lang.org/nightly/std/os/raw/type.c_int.html" title="type std::os::raw::c_int">c_int</a>, <a class="struct" href="struct.Error.html" title="struct kvm_ioctls::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Directly injects a MSI message as per the <code>KVM_SIGNAL_MSI</code> ioctl.</p>
<p>See the documentation for <code>KVM_SIGNAL_MSI</code>.</p>
<p>This ioctl returns &gt; 0 when the MSI is successfully delivered and 0
when the guest blocked the MSI.</p>
<h5 id="arguments-10"><a href="#arguments-10">Arguments</a></h5>
<ul>
<li>kvm_msi - MSI message configuration. For details check the <code>kvm_msi</code> structure in the
<a href="https://www.kernel.org/doc/Documentation/virtual/kvm/api.txt">KVM API doc</a>.</li>
</ul>
<h5 id="example-11"><a href="#example-11">Example</a></h5>
<p>In this example, the important function signal_msi() calling into
the actual ioctl is commented out. The reason is that MSI vectors are
not chosen from the HW side (VMM). The guest OS (or anything that runs
inside the VM) is supposed to allocate the MSI vectors, and usually
communicate back through PCI configuration space. Sending a random MSI
vector through this signal_msi() function will always result in a
failure, which is why it needs to be commented out.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">kvm_bindings</span>;
<span class="kw">use</span> <span class="ident">kvm_bindings::kvm_msi</span>;

<span class="kw">let</span> <span class="ident">kvm</span> <span class="op">=</span> <span class="ident">Kvm::new</span>().<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">vm</span> <span class="op">=</span> <span class="ident">kvm</span>.<span class="ident">create_vm</span>().<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">msi</span> <span class="op">=</span> <span class="ident">kvm_msi::default</span>();
<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">any</span>(<span class="ident">target_arch</span> <span class="op">=</span> <span class="string">&quot;x86&quot;</span>, <span class="ident">target_arch</span> <span class="op">=</span> <span class="string">&quot;x86_64&quot;</span>))]</span>
<span class="ident">vm</span>.<span class="ident">create_irq_chip</span>().<span class="ident">unwrap</span>();
<span class="comment">//vm.signal_msi(msi).unwrap();</span></code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.set_gsi_routing" class="method has-srclink"><span class="rightside"><a class="srclink" href="../src/kvm_ioctls/ioctls/vm.rs.html#550-559">source</a></span><a href="#method.set_gsi_routing" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.set_gsi_routing" class="fnname">set_gsi_routing</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;irq_routing: &amp;<a class="struct" href="../kvm_bindings/x86/bindings/struct.kvm_irq_routing.html" title="struct kvm_bindings::x86::bindings::kvm_irq_routing">kvm_irq_routing</a><br>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>, <a class="struct" href="struct.Error.html" title="struct kvm_ioctls::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Sets the GSI routing table entries, overwriting any previously set
entries, as per the <code>KVM_SET_GSI_ROUTING</code> ioctl.</p>
<p>See the documentation for <code>KVM_SET_GSI_ROUTING</code>.</p>
<p>Returns an io::Error when the table could not be updated.</p>
<h5 id="arguments-11"><a href="#arguments-11">Arguments</a></h5>
<ul>
<li>kvm_irq_routing - IRQ routing configuration. Describe all routes
associated with GSI entries. For details check
the <code>kvm_irq_routing</code> and <code>kvm_irq_routing_entry</code>
structures in the
<a href="https://www.kernel.org/doc/Documentation/virtual/kvm/api.txt">KVM API doc</a>.</li>
</ul>
<h5 id="example-12"><a href="#example-12">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">kvm_bindings</span>;
<span class="kw">use</span> <span class="ident">kvm_bindings::kvm_irq_routing</span>;

<span class="kw">let</span> <span class="ident">kvm</span> <span class="op">=</span> <span class="ident">Kvm::new</span>().<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">vm</span> <span class="op">=</span> <span class="ident">kvm</span>.<span class="ident">create_vm</span>().<span class="ident">unwrap</span>();
<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">any</span>(<span class="ident">target_arch</span> <span class="op">=</span> <span class="string">&quot;x86&quot;</span>, <span class="ident">target_arch</span> <span class="op">=</span> <span class="string">&quot;x86_64&quot;</span>))]</span>
<span class="ident">vm</span>.<span class="ident">create_irq_chip</span>().<span class="ident">unwrap</span>();

<span class="kw">let</span> <span class="ident">irq_routing</span> <span class="op">=</span> <span class="ident">kvm_irq_routing::default</span>();
<span class="ident">vm</span>.<span class="ident">set_gsi_routing</span>(<span class="kw-2">&amp;</span><span class="ident">irq_routing</span>).<span class="ident">unwrap</span>();</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.register_ioevent" class="method has-srclink"><span class="rightside"><a class="srclink" href="../src/kvm_ioctls/ioctls/vm.rs.html#593-626">source</a></span><a href="#method.register_ioevent" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.register_ioevent" class="fnname">register_ioevent</a>&lt;T:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u64.html">u64</a>&gt;&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;fd: &amp;<a class="struct" href="../vmm_sys_util/linux/eventfd/struct.EventFd.html" title="struct vmm_sys_util::linux::eventfd::EventFd">EventFd</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;addr: &amp;<a class="enum" href="enum.IoEventAddress.html" title="enum kvm_ioctls::IoEventAddress">IoEventAddress</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;datamatch: T<br>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>, <a class="struct" href="struct.Error.html" title="struct kvm_ioctls::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Registers an event to be signaled whenever a certain address is written to.</p>
<p>See the documentation for <code>KVM_IOEVENTFD</code>.</p>
<h5 id="arguments-12"><a href="#arguments-12">Arguments</a></h5>
<ul>
<li><code>fd</code> - <code>EventFd</code> which will be signaled. When signaling, the usual <code>vmexit</code> to userspace
is prevented.</li>
<li><code>addr</code> - Address being written to.</li>
<li><code>datamatch</code> - Limits signaling <code>fd</code> to only the cases where the value being written is
equal to this parameter. The size of <code>datamatch</code> is important and it must
match the expected size of the guest’s write.</li>
</ul>
<h5 id="example-13"><a href="#example-13">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">libc</span>;
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">vmm_sys_util</span>;
<span class="kw">use</span> <span class="ident">libc</span>::{<span class="ident">eventfd</span>, <span class="ident">EFD_NONBLOCK</span>};
<span class="kw">use</span> <span class="ident">vmm_sys_util::eventfd::EventFd</span>;
<span class="kw">let</span> <span class="ident">kvm</span> <span class="op">=</span> <span class="ident">Kvm::new</span>().<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">vm_fd</span> <span class="op">=</span> <span class="ident">kvm</span>.<span class="ident">create_vm</span>().<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">evtfd</span> <span class="op">=</span> <span class="ident">EventFd::new</span>(<span class="ident">EFD_NONBLOCK</span>).<span class="ident">unwrap</span>();
<span class="ident">vm_fd</span>
    .<span class="ident">register_ioevent</span>(<span class="kw-2">&amp;</span><span class="ident">evtfd</span>, <span class="kw-2">&amp;</span><span class="ident">IoEventAddress::Pio</span>(<span class="number">0xf4</span>), <span class="ident">NoDatamatch</span>)
    .<span class="ident">unwrap</span>();
<span class="ident">vm_fd</span>
    .<span class="ident">register_ioevent</span>(<span class="kw-2">&amp;</span><span class="ident">evtfd</span>, <span class="kw-2">&amp;</span><span class="ident">IoEventAddress::Mmio</span>(<span class="number">0x1000</span>), <span class="ident">NoDatamatch</span>)
    .<span class="ident">unwrap</span>();</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.unregister_ioevent" class="method has-srclink"><span class="rightside"><a class="srclink" href="../src/kvm_ioctls/ioctls/vm.rs.html#669-702">source</a></span><a href="#method.unregister_ioevent" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.unregister_ioevent" class="fnname">unregister_ioevent</a>&lt;T:&nbsp;<a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u64.html">u64</a>&gt;&gt;(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;fd: &amp;<a class="struct" href="../vmm_sys_util/linux/eventfd/struct.EventFd.html" title="struct vmm_sys_util::linux::eventfd::EventFd">EventFd</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;addr: &amp;<a class="enum" href="enum.IoEventAddress.html" title="enum kvm_ioctls::IoEventAddress">IoEventAddress</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;datamatch: T<br>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>, <a class="struct" href="struct.Error.html" title="struct kvm_ioctls::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Unregisters an event from a certain address it has been previously registered to.</p>
<p>See the documentation for <code>KVM_IOEVENTFD</code>.</p>
<h5 id="arguments-13"><a href="#arguments-13">Arguments</a></h5>
<ul>
<li><code>fd</code> - FD which will be unregistered.</li>
<li><code>addr</code> - Address being written to.</li>
</ul>
<h5 id="safety-1"><a href="#safety-1">Safety</a></h5>
<p>This function is unsafe because it relies on RawFd.</p>
<h5 id="example-14"><a href="#example-14">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">libc</span>;
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">vmm_sys_util</span>;
<span class="kw">use</span> <span class="ident">libc::EFD_NONBLOCK</span>;
<span class="kw">use</span> <span class="ident">vmm_sys_util::eventfd::EventFd</span>;

<span class="kw">let</span> <span class="ident">kvm</span> <span class="op">=</span> <span class="ident">Kvm::new</span>().<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">vm_fd</span> <span class="op">=</span> <span class="ident">kvm</span>.<span class="ident">create_vm</span>().<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">evtfd</span> <span class="op">=</span> <span class="ident">EventFd::new</span>(<span class="ident">EFD_NONBLOCK</span>).<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">pio_addr</span> <span class="op">=</span> <span class="ident">IoEventAddress::Pio</span>(<span class="number">0xf4</span>);
<span class="kw">let</span> <span class="ident">mmio_addr</span> <span class="op">=</span> <span class="ident">IoEventAddress::Mmio</span>(<span class="number">0x1000</span>);
<span class="ident">vm_fd</span>
    .<span class="ident">register_ioevent</span>(<span class="kw-2">&amp;</span><span class="ident">evtfd</span>, <span class="kw-2">&amp;</span><span class="ident">pio_addr</span>, <span class="ident">NoDatamatch</span>)
    .<span class="ident">unwrap</span>();
<span class="ident">vm_fd</span>
    .<span class="ident">register_ioevent</span>(<span class="kw-2">&amp;</span><span class="ident">evtfd</span>, <span class="kw-2">&amp;</span><span class="ident">mmio_addr</span>, <span class="number">0x1234u32</span>)
    .<span class="ident">unwrap</span>();
<span class="ident">vm_fd</span>
    .<span class="ident">unregister_ioevent</span>(<span class="kw-2">&amp;</span><span class="ident">evtfd</span>, <span class="kw-2">&amp;</span><span class="ident">pio_addr</span>, <span class="ident">NoDatamatch</span>)
    .<span class="ident">unwrap</span>();
<span class="ident">vm_fd</span>
    .<span class="ident">unregister_ioevent</span>(<span class="kw-2">&amp;</span><span class="ident">evtfd</span>, <span class="kw-2">&amp;</span><span class="ident">mmio_addr</span>, <span class="number">0x1234u32</span>)
    .<span class="ident">unwrap</span>();</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.get_dirty_log" class="method has-srclink"><span class="rightside"><a class="srclink" href="../src/kvm_ioctls/ioctls/vm.rs.html#820-850">source</a></span><a href="#method.get_dirty_log" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.get_dirty_log" class="fnname">get_dirty_log</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;slot: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;memory_size: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a><br>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u64.html">u64</a>&gt;, <a class="struct" href="struct.Error.html" title="struct kvm_ioctls::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Gets the bitmap of pages dirtied since the last call of this function.</p>
<p>Leverages the dirty page logging feature in KVM. As a side-effect, this also resets the
bitmap inside the kernel. For the dirty log to be available, you have to set the flag
<code>KVM_MEM_LOG_DIRTY_PAGES</code> when creating guest memory regions.</p>
<p>Check the documentation for <code>KVM_GET_DIRTY_LOG</code>.</p>
<h5 id="arguments-14"><a href="#arguments-14">Arguments</a></h5>
<ul>
<li><code>slot</code> - Guest memory slot identifier.</li>
<li><code>memory_size</code> - Size of the memory region.</li>
</ul>
<h5 id="example-15"><a href="#example-15">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// This example is based on https://lwn.net/Articles/658511/.</span>
<span class="kw">let</span> <span class="ident">mem_size</span> <span class="op">=</span> <span class="number">0x4000</span>;
<span class="kw">let</span> <span class="ident">guest_addr</span>: <span class="ident">u64</span> <span class="op">=</span> <span class="number">0x1000</span>;
<span class="kw">let</span> <span class="ident">load_addr</span>: <span class="kw-2">*mut</span> <span class="ident">u8</span> <span class="op">=</span> <span class="kw">unsafe</span> {
    <span class="ident">libc::mmap</span>(
        <span class="ident">null_mut</span>(),
        <span class="ident">mem_size</span>,
        <span class="ident">libc::PROT_READ</span> <span class="op">|</span> <span class="ident">libc::PROT_WRITE</span>,
        <span class="ident">libc::MAP_ANONYMOUS</span> <span class="op">|</span> <span class="ident">libc::MAP_SHARED</span> <span class="op">|</span> <span class="ident">libc::MAP_NORESERVE</span>,
        <span class="op">-</span><span class="number">1</span>,
        <span class="number">0</span>,
    ) <span class="kw">as</span> <span class="kw-2">*mut</span> <span class="ident">u8</span>
};

<span class="comment">// Initialize a guest memory region using the flag `KVM_MEM_LOG_DIRTY_PAGES`.</span>
<span class="kw">let</span> <span class="ident">mem_region</span> <span class="op">=</span> <span class="ident">kvm_userspace_memory_region</span> {
    <span class="ident">slot</span>: <span class="number">0</span>,
    <span class="ident">guest_phys_addr</span>: <span class="ident">guest_addr</span>,
    <span class="ident">memory_size</span>: <span class="ident">mem_size</span> <span class="kw">as</span> <span class="ident">u64</span>,
    <span class="ident">userspace_addr</span>: <span class="ident">load_addr</span> <span class="kw">as</span> <span class="ident">u64</span>,
    <span class="ident">flags</span>: <span class="ident">KVM_MEM_LOG_DIRTY_PAGES</span>,
};
<span class="kw">unsafe</span> { <span class="ident">vm</span>.<span class="ident">set_user_memory_region</span>(<span class="ident">mem_region</span>).<span class="ident">unwrap</span>() };

<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">any</span>(<span class="ident">target_arch</span> <span class="op">=</span> <span class="string">&quot;x86&quot;</span>, <span class="ident">target_arch</span> <span class="op">=</span> <span class="string">&quot;x86_64&quot;</span>))]</span>
<span class="comment">// ASM code that just forces a MMIO Write.</span>
<span class="kw">let</span> <span class="ident">asm_code</span> <span class="op">=</span> [<span class="number">0xc6</span>, <span class="number">0x06</span>, <span class="number">0x00</span>, <span class="number">0x80</span>, <span class="number">0x00</span>];
<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">target_arch</span> <span class="op">=</span> <span class="string">&quot;aarch64&quot;</span>)]</span>
<span class="kw">let</span> <span class="ident">asm_code</span> <span class="op">=</span> [
    <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x10</span>, <span class="comment">/* adr x1, &lt;this address&gt; */</span>
    <span class="number">0x22</span>, <span class="number">0x10</span>, <span class="number">0x00</span>, <span class="number">0xb9</span>, <span class="comment">/* str w2, [x1, #16]; write to this page */</span>
    <span class="number">0x02</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0xb9</span>, <span class="comment">/* str w2, [x0]; force MMIO exit */</span>
    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,
    <span class="number">0x14</span>, <span class="comment">/* b &lt;this address&gt;; shouldn&#39;t get here, but if so loop forever */</span>
];

<span class="comment">// Write the code in the guest memory. This will generate a dirty page.</span>
<span class="kw">unsafe</span> {
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">slice</span> <span class="op">=</span> <span class="ident">slice::from_raw_parts_mut</span>(<span class="ident">load_addr</span>, <span class="ident">mem_size</span>);
    <span class="ident">slice</span>.<span class="ident">write</span>(<span class="kw-2">&amp;</span><span class="ident">asm_code</span>).<span class="ident">unwrap</span>();
}

<span class="kw">let</span> <span class="ident">vcpu_fd</span> <span class="op">=</span> <span class="ident">vm</span>.<span class="ident">create_vcpu</span>(<span class="number">0</span>).<span class="ident">unwrap</span>();

<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">any</span>(<span class="ident">target_arch</span> <span class="op">=</span> <span class="string">&quot;x86&quot;</span>, <span class="ident">target_arch</span> <span class="op">=</span> <span class="string">&quot;x86_64&quot;</span>))]</span>
{
    <span class="comment">// x86_64 specific registry setup.</span>
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">vcpu_sregs</span> <span class="op">=</span> <span class="ident">vcpu_fd</span>.<span class="ident">get_sregs</span>().<span class="ident">unwrap</span>();
    <span class="ident">vcpu_sregs</span>.<span class="ident">cs</span>.<span class="ident">base</span> <span class="op">=</span> <span class="number">0</span>;
    <span class="ident">vcpu_sregs</span>.<span class="ident">cs</span>.<span class="ident">selector</span> <span class="op">=</span> <span class="number">0</span>;
    <span class="ident">vcpu_fd</span>.<span class="ident">set_sregs</span>(<span class="kw-2">&amp;</span><span class="ident">vcpu_sregs</span>).<span class="ident">unwrap</span>();

    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">vcpu_regs</span> <span class="op">=</span> <span class="ident">vcpu_fd</span>.<span class="ident">get_regs</span>().<span class="ident">unwrap</span>();
    <span class="comment">// Set the Instruction Pointer to the guest address where we loaded the code.</span>
    <span class="ident">vcpu_regs</span>.<span class="ident">rip</span> <span class="op">=</span> <span class="ident">guest_addr</span>;
    <span class="ident">vcpu_regs</span>.<span class="ident">rax</span> <span class="op">=</span> <span class="number">2</span>;
    <span class="ident">vcpu_regs</span>.<span class="ident">rbx</span> <span class="op">=</span> <span class="number">3</span>;
    <span class="ident">vcpu_regs</span>.<span class="ident">rflags</span> <span class="op">=</span> <span class="number">2</span>;
    <span class="ident">vcpu_fd</span>.<span class="ident">set_regs</span>(<span class="kw-2">&amp;</span><span class="ident">vcpu_regs</span>).<span class="ident">unwrap</span>();
}

<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">target_arch</span> <span class="op">=</span> <span class="string">&quot;aarch64&quot;</span>)]</span>
{
    <span class="comment">// aarch64 specific registry setup.</span>
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">kvi</span> <span class="op">=</span> <span class="ident">kvm_bindings::kvm_vcpu_init::default</span>();
    <span class="ident">vm</span>.<span class="ident">get_preferred_target</span>(<span class="kw-2">&amp;mut</span> <span class="ident">kvi</span>).<span class="ident">unwrap</span>();
    <span class="ident">vcpu_fd</span>.<span class="ident">vcpu_init</span>(<span class="kw-2">&amp;</span><span class="ident">kvi</span>).<span class="ident">unwrap</span>();

    <span class="kw">let</span> <span class="ident">core_reg_base</span>: <span class="ident">u64</span> <span class="op">=</span> <span class="number">0x6030_0000_0010_0000</span>;
    <span class="kw">let</span> <span class="ident">mmio_addr</span>: <span class="ident">u64</span> <span class="op">=</span> <span class="ident">guest_addr</span> <span class="op">+</span> <span class="ident">mem_size</span> <span class="kw">as</span> <span class="ident">u64</span>;
    <span class="ident">vcpu_fd</span>.<span class="ident">set_one_reg</span>(<span class="ident">core_reg_base</span> <span class="op">+</span> <span class="number">2</span> <span class="op">*</span> <span class="number">32</span>, <span class="ident">guest_addr</span> <span class="kw">as</span> <span class="ident">u128</span>); <span class="comment">// set PC</span>
    <span class="ident">vcpu_fd</span>.<span class="ident">set_one_reg</span>(<span class="ident">core_reg_base</span> <span class="op">+</span> <span class="number">2</span> <span class="op">*</span> <span class="number">0</span>, <span class="ident">mmio_addr</span> <span class="kw">as</span> <span class="ident">u128</span>); <span class="comment">// set X0</span>
}

<span class="kw">loop</span> {
    <span class="kw">match</span> <span class="ident">vcpu_fd</span>.<span class="ident">run</span>().<span class="ident">expect</span>(<span class="string">&quot;run failed&quot;</span>) {
        <span class="ident">VcpuExit::MmioWrite</span>(<span class="ident">addr</span>, <span class="ident">data</span>) =&gt; {
            <span class="comment">// On x86_64, the code snippet dirties 1 page when loading the code in memory</span>
            <span class="comment">// while on aarch64 the dirty bit comes from writing to guest_addr (current PC).</span>
            <span class="kw">let</span> <span class="ident">dirty_pages_bitmap</span> <span class="op">=</span> <span class="ident">vm</span>.<span class="ident">get_dirty_log</span>(<span class="number">0</span>, <span class="ident">mem_size</span>).<span class="ident">unwrap</span>();
            <span class="kw">let</span> <span class="ident">dirty_pages</span> <span class="op">=</span> <span class="ident">dirty_pages_bitmap</span>
                .<span class="ident">into_iter</span>()
                .<span class="ident">map</span>(<span class="op">|</span><span class="ident">page</span><span class="op">|</span> <span class="ident">page</span>.<span class="ident">count_ones</span>())
                .<span class="ident">fold</span>(<span class="number">0</span>, <span class="op">|</span><span class="ident">dirty_page_count</span>, <span class="ident">i</span><span class="op">|</span> <span class="ident">dirty_page_count</span> <span class="op">+</span> <span class="ident">i</span>);
            <span class="macro">assert_eq!</span>(<span class="ident">dirty_pages</span>, <span class="number">1</span>);
            <span class="kw">break</span>;
        }
        <span class="ident">exit_reason</span> =&gt; <span class="macro">panic!</span>(<span class="string">&quot;unexpected exit reason: {:?}&quot;</span>, <span class="ident">exit_reason</span>),
    }
}</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.register_irqfd" class="method has-srclink"><span class="rightside"><a class="srclink" href="../src/kvm_ioctls/ioctls/vm.rs.html#883-897">source</a></span><a href="#method.register_irqfd" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.register_irqfd" class="fnname">register_irqfd</a>(&amp;self, fd: &amp;<a class="struct" href="../vmm_sys_util/linux/eventfd/struct.EventFd.html" title="struct vmm_sys_util::linux::eventfd::EventFd">EventFd</a>, gsi: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>, <a class="struct" href="struct.Error.html" title="struct kvm_ioctls::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Registers an event that will, when signaled, trigger the <code>gsi</code> IRQ.</p>
<h5 id="arguments-15"><a href="#arguments-15">Arguments</a></h5>
<ul>
<li><code>fd</code> - <code>EventFd</code> to be signaled.</li>
<li><code>gsi</code> - IRQ to be triggered.</li>
</ul>
<h5 id="example-16"><a href="#example-16">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">kvm</span> <span class="op">=</span> <span class="ident">Kvm::new</span>().<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">vm</span> <span class="op">=</span> <span class="ident">kvm</span>.<span class="ident">create_vm</span>().<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">evtfd</span> <span class="op">=</span> <span class="ident">EventFd::new</span>(<span class="ident">EFD_NONBLOCK</span>).<span class="ident">unwrap</span>();
<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">any</span>(<span class="ident">target_arch</span> <span class="op">=</span> <span class="string">&quot;x86&quot;</span>, <span class="ident">target_arch</span> <span class="op">=</span> <span class="string">&quot;x86_64&quot;</span>))]</span>
{
    <span class="ident">vm</span>.<span class="ident">create_irq_chip</span>().<span class="ident">unwrap</span>();
    <span class="ident">vm</span>.<span class="ident">register_irqfd</span>(<span class="kw-2">&amp;</span><span class="ident">evtfd</span>, <span class="number">0</span>).<span class="ident">unwrap</span>();
}</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.register_irqfd_with_resample" class="method has-srclink"><span class="rightside"><a class="srclink" href="../src/kvm_ioctls/ioctls/vm.rs.html#935-956">source</a></span><a href="#method.register_irqfd_with_resample" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.register_irqfd_with_resample" class="fnname">register_irqfd_with_resample</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;fd: &amp;<a class="struct" href="../vmm_sys_util/linux/eventfd/struct.EventFd.html" title="struct vmm_sys_util::linux::eventfd::EventFd">EventFd</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;resamplefd: &amp;<a class="struct" href="../vmm_sys_util/linux/eventfd/struct.EventFd.html" title="struct vmm_sys_util::linux::eventfd::EventFd">EventFd</a>, <br>&nbsp;&nbsp;&nbsp;&nbsp;gsi: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a><br>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>, <a class="struct" href="struct.Error.html" title="struct kvm_ioctls::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Registers an event that will, when signaled, assert the <code>gsi</code> IRQ.
If the irqchip is resampled by the guest, the IRQ is de-asserted,
and <code>resamplefd</code> is notified.</p>
<h5 id="arguments-16"><a href="#arguments-16">Arguments</a></h5>
<ul>
<li><code>fd</code> - <code>EventFd</code> to be signaled.</li>
<li><code>resamplefd</code> - <code>EventFd</code>to be notified on resample.</li>
<li><code>gsi</code> - IRQ to be triggered.</li>
</ul>
<h5 id="example-17"><a href="#example-17">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">kvm</span> <span class="op">=</span> <span class="ident">Kvm::new</span>().<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">vm</span> <span class="op">=</span> <span class="ident">kvm</span>.<span class="ident">create_vm</span>().<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">evtfd</span> <span class="op">=</span> <span class="ident">EventFd::new</span>(<span class="ident">EFD_NONBLOCK</span>).<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">resamplefd</span> <span class="op">=</span> <span class="ident">EventFd::new</span>(<span class="ident">EFD_NONBLOCK</span>).<span class="ident">unwrap</span>();
<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">any</span>(<span class="ident">target_arch</span> <span class="op">=</span> <span class="string">&quot;x86&quot;</span>, <span class="ident">target_arch</span> <span class="op">=</span> <span class="string">&quot;x86_64&quot;</span>))]</span>
{
    <span class="ident">vm</span>.<span class="ident">create_irq_chip</span>().<span class="ident">unwrap</span>();
    <span class="ident">vm</span>.<span class="ident">register_irqfd_with_resample</span>(<span class="kw-2">&amp;</span><span class="ident">evtfd</span>, <span class="kw-2">&amp;</span><span class="ident">resamplefd</span>, <span class="number">0</span>)
        .<span class="ident">unwrap</span>();
}</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.unregister_irqfd" class="method has-srclink"><span class="rightside"><a class="srclink" href="../src/kvm_ioctls/ioctls/vm.rs.html#994-1009">source</a></span><a href="#method.unregister_irqfd" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.unregister_irqfd" class="fnname">unregister_irqfd</a>(&amp;self, fd: &amp;<a class="struct" href="../vmm_sys_util/linux/eventfd/struct.EventFd.html" title="struct vmm_sys_util::linux::eventfd::EventFd">EventFd</a>, gsi: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>, <a class="struct" href="struct.Error.html" title="struct kvm_ioctls::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Unregisters an event that will, when signaled, trigger the <code>gsi</code> IRQ.</p>
<h5 id="arguments-17"><a href="#arguments-17">Arguments</a></h5>
<ul>
<li><code>fd</code> - <code>EventFd</code> to be signaled.</li>
<li><code>gsi</code> - IRQ to be triggered.</li>
</ul>
<h5 id="example-18"><a href="#example-18">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">kvm</span> <span class="op">=</span> <span class="ident">Kvm::new</span>().<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">vm</span> <span class="op">=</span> <span class="ident">kvm</span>.<span class="ident">create_vm</span>().<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">evtfd</span> <span class="op">=</span> <span class="ident">EventFd::new</span>(<span class="ident">EFD_NONBLOCK</span>).<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">resamplefd</span> <span class="op">=</span> <span class="ident">EventFd::new</span>(<span class="ident">EFD_NONBLOCK</span>).<span class="ident">unwrap</span>();
<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">any</span>(<span class="ident">target_arch</span> <span class="op">=</span> <span class="string">&quot;x86&quot;</span>, <span class="ident">target_arch</span> <span class="op">=</span> <span class="string">&quot;x86_64&quot;</span>))]</span>
{
    <span class="ident">vm</span>.<span class="ident">create_irq_chip</span>().<span class="ident">unwrap</span>();
    <span class="ident">vm</span>.<span class="ident">register_irqfd</span>(<span class="kw-2">&amp;</span><span class="ident">evtfd</span>, <span class="number">0</span>).<span class="ident">unwrap</span>();
    <span class="ident">vm</span>.<span class="ident">unregister_irqfd</span>(<span class="kw-2">&amp;</span><span class="ident">evtfd</span>, <span class="number">0</span>).<span class="ident">unwrap</span>();
    <span class="ident">vm</span>.<span class="ident">register_irqfd_with_resample</span>(<span class="kw-2">&amp;</span><span class="ident">evtfd</span>, <span class="kw-2">&amp;</span><span class="ident">resamplefd</span>, <span class="number">0</span>)
        .<span class="ident">unwrap</span>();
    <span class="ident">vm</span>.<span class="ident">unregister_irqfd</span>(<span class="kw-2">&amp;</span><span class="ident">evtfd</span>, <span class="number">0</span>).<span class="ident">unwrap</span>();
}</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.set_irq_line" class="method has-srclink"><span class="rightside"><a class="srclink" href="../src/kvm_ioctls/ioctls/vm.rs.html#1065-1078">source</a></span><a href="#method.set_irq_line" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.set_irq_line" class="fnname">set_irq_line</a>(&amp;self, irq: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u32.html">u32</a>, active: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>, <a class="struct" href="struct.Error.html" title="struct kvm_ioctls::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Sets the level on the given irq to 1 if <code>active</code> is true, and 0 otherwise.</p>
<h5 id="arguments-18"><a href="#arguments-18">Arguments</a></h5>
<ul>
<li><code>irq</code> - IRQ to be set.</li>
<li><code>active</code> - Level of the IRQ input.</li>
</ul>
<h5 id="errors"><a href="#errors">Errors</a></h5>
<p>Returns an io::Error when the irq field is invalid</p>
<h5 id="examples"><a href="#examples">Examples</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">fn</span> <span class="ident">arch_setup</span>(<span class="ident">vm_fd</span>: <span class="kw-2">&amp;</span><span class="ident">VmFd</span>) {
    <span class="comment">// Arch-specific setup:</span>
    <span class="comment">// For x86 architectures, it simply means calling vm.create_irq_chip().unwrap().</span>
    <span class="comment">// For Arm architectures, the IRQ controllers need to be setup first.</span>
    <span class="comment">// Details please refer to the kernel documentation.</span>
    <span class="comment">// https://www.kernel.org/doc/Documentation/virtual/kvm/api.txt</span>
}

<span class="kw">let</span> <span class="ident">kvm</span> <span class="op">=</span> <span class="ident">Kvm::new</span>().<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">vm</span> <span class="op">=</span> <span class="ident">kvm</span>.<span class="ident">create_vm</span>().<span class="ident">unwrap</span>();
<span class="ident">arch_setup</span>(<span class="kw-2">&amp;</span><span class="ident">vm</span>);
<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">any</span>(<span class="ident">target_arch</span> <span class="op">=</span> <span class="string">&quot;x86&quot;</span>, <span class="ident">target_arch</span> <span class="op">=</span> <span class="string">&quot;x86_64&quot;</span>))]</span>
{
    <span class="ident">vm</span>.<span class="ident">set_irq_line</span>(<span class="number">4</span>, <span class="bool-val">true</span>);
    <span class="comment">// ...</span>
}
<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">any</span>(<span class="ident">target_arch</span> <span class="op">=</span> <span class="string">&quot;arm&quot;</span>, <span class="ident">target_arch</span> <span class="op">=</span> <span class="string">&quot;aarch64&quot;</span>))]</span>
{
    <span class="ident">vm</span>.<span class="ident">set_irq_line</span>(<span class="number">0x01_00_0020</span>, <span class="bool-val">true</span>);
    <span class="comment">// ....</span>
}</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.create_vcpu" class="method has-srclink"><span class="rightside"><a class="srclink" href="../src/kvm_ioctls/ioctls/vm.rs.html#1104-1119">source</a></span><a href="#method.create_vcpu" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.create_vcpu" class="fnname">create_vcpu</a>(&amp;self, id: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u64.html">u64</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.VcpuFd.html" title="struct kvm_ioctls::VcpuFd">VcpuFd</a>, <a class="struct" href="struct.Error.html" title="struct kvm_ioctls::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Creates a new KVM vCPU file descriptor and maps the memory corresponding
its <code>kvm_run</code> structure.</p>
<p>See the documentation for <code>KVM_CREATE_VCPU</code>.</p>
<h5 id="arguments-19"><a href="#arguments-19">Arguments</a></h5>
<ul>
<li><code>id</code> - The vCPU ID.</li>
</ul>
<h5 id="errors-1"><a href="#errors-1">Errors</a></h5>
<p>Returns an io::Error when the VM fd is invalid or the vCPU memory cannot
be mapped correctly.</p>
<h5 id="example-19"><a href="#example-19">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">kvm</span> <span class="op">=</span> <span class="ident">Kvm::new</span>().<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">vm</span> <span class="op">=</span> <span class="ident">kvm</span>.<span class="ident">create_vm</span>().<span class="ident">unwrap</span>();
<span class="comment">// Create one vCPU with the ID=0.</span>
<span class="kw">let</span> <span class="ident">vcpu</span> <span class="op">=</span> <span class="ident">vm</span>.<span class="ident">create_vcpu</span>(<span class="number">0</span>);</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.create_vcpu_from_rawfd" class="method has-srclink"><span class="rightside"><a class="srclink" href="../src/kvm_ioctls/ioctls/vm.rs.html#1150-1154">source</a></span><a href="#method.create_vcpu_from_rawfd" class="anchor"></a><h4 class="code-header">pub unsafe fn <a href="#method.create_vcpu_from_rawfd" class="fnname">create_vcpu_from_rawfd</a>(&amp;self, fd: <a class="type" href="https://doc.rust-lang.org/nightly/std/os/fd/raw/type.RawFd.html" title="type std::os::fd::raw::RawFd">RawFd</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.VcpuFd.html" title="struct kvm_ioctls::VcpuFd">VcpuFd</a>, <a class="struct" href="struct.Error.html" title="struct kvm_ioctls::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Creates a VcpuFd object from a vcpu RawFd.</p>
<h5 id="arguments-20"><a href="#arguments-20">Arguments</a></h5>
<ul>
<li><code>fd</code> - the RawFd used for creating the VcpuFd object.</li>
</ul>
<h5 id="safety-2"><a href="#safety-2">Safety</a></h5>
<p>This function is unsafe as the primitives currently returned have the contract that
they are the sole owner of the file descriptor they are wrapping. Usage of this function
could accidentally allow violating this contract which can cause memory unsafety in code
that relies on it being true.</p>
<p>The caller of this method must make sure the fd is valid and nothing else uses it.</p>
<h5 id="example-20"><a href="#example-20">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let</span> <span class="ident">kvm</span> <span class="op">=</span> <span class="ident">Kvm::new</span>().<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">vm</span> <span class="op">=</span> <span class="ident">kvm</span>.<span class="ident">create_vm</span>().<span class="ident">unwrap</span>();
<span class="comment">// Create one vCPU with the ID=0.</span>
<span class="kw">let</span> <span class="ident">vcpu</span> <span class="op">=</span> <span class="ident">vm</span>.<span class="ident">create_vcpu</span>(<span class="number">0</span>).<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">rawfd</span> <span class="op">=</span> <span class="kw">unsafe</span> { <span class="ident">libc::dup</span>(<span class="ident">vcpu</span>.<span class="ident">as_raw_fd</span>()) };
<span class="macro">assert!</span>(<span class="ident">rawfd</span> <span class="op">&gt;</span><span class="op">=</span> <span class="number">0</span>);
<span class="kw">let</span> <span class="ident">vcpu</span> <span class="op">=</span> <span class="kw">unsafe</span> { <span class="ident">vm</span>.<span class="ident">create_vcpu_from_rawfd</span>(<span class="ident">rawfd</span>).<span class="ident">unwrap</span>() };</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.create_device" class="method has-srclink"><span class="rightside"><a class="srclink" href="../src/kvm_ioctls/ioctls/vm.rs.html#1202-1209">source</a></span><a href="#method.create_device" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.create_device" class="fnname">create_device</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;device: &amp;mut <a class="struct" href="../kvm_bindings/x86/bindings/struct.kvm_create_device.html" title="struct kvm_bindings::x86::bindings::kvm_create_device">kvm_create_device</a><br>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="struct" href="struct.DeviceFd.html" title="struct kvm_ioctls::DeviceFd">DeviceFd</a>, <a class="struct" href="struct.Error.html" title="struct kvm_ioctls::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Creates an emulated device in the kernel.</p>
<p>See the documentation for <code>KVM_CREATE_DEVICE</code>.</p>
<h5 id="arguments-21"><a href="#arguments-21">Arguments</a></h5>
<ul>
<li><code>device</code>: device configuration. For details check the <code>kvm_create_device</code> structure in the
<a href="https://www.kernel.org/doc/Documentation/virtual/kvm/api.txt">KVM API doc</a>.</li>
</ul>
<h5 id="example-21"><a href="#example-21">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">kvm_bindings</span>::{
    <span class="ident">kvm_device_type_KVM_DEV_TYPE_ARM_VGIC_V2</span>, <span class="ident">kvm_device_type_KVM_DEV_TYPE_ARM_VGIC_V3</span>,
    <span class="ident">kvm_device_type_KVM_DEV_TYPE_VFIO</span>, <span class="ident">KVM_CREATE_DEVICE_TEST</span>,
};
<span class="kw">let</span> <span class="ident">kvm</span> <span class="op">=</span> <span class="ident">Kvm::new</span>().<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">vm</span> <span class="op">=</span> <span class="ident">kvm</span>.<span class="ident">create_vm</span>().<span class="ident">unwrap</span>();

<span class="comment">// Creating a device with the KVM_CREATE_DEVICE_TEST flag to check</span>
<span class="comment">// whether the device type is supported. This will not create the device.</span>
<span class="comment">// To create the device the flag needs to be removed.</span>
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">device</span> <span class="op">=</span> <span class="ident">kvm_bindings::kvm_create_device</span> {
    <span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">any</span>(<span class="ident">target_arch</span> <span class="op">=</span> <span class="string">&quot;x86&quot;</span>, <span class="ident">target_arch</span> <span class="op">=</span> <span class="string">&quot;x86_64&quot;</span>))]</span>
    <span class="ident">type_</span>: <span class="ident">kvm_device_type_KVM_DEV_TYPE_VFIO</span>,
    <span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">any</span>(<span class="ident">target_arch</span> <span class="op">=</span> <span class="string">&quot;arm&quot;</span>, <span class="ident">target_arch</span> <span class="op">=</span> <span class="string">&quot;aarch64&quot;</span>))]</span>
    <span class="ident">type_</span>: <span class="ident">kvm_device_type_KVM_DEV_TYPE_ARM_VGIC_V3</span>,
    <span class="ident">fd</span>: <span class="number">0</span>,
    <span class="ident">flags</span>: <span class="ident">KVM_CREATE_DEVICE_TEST</span>,
};
<span class="comment">// On ARM, creating VGICv3 may fail due to hardware dependency.</span>
<span class="comment">// Retry to create VGICv2 in that case.</span>
<span class="kw">let</span> <span class="ident">device_fd</span> <span class="op">=</span> <span class="ident">vm</span>.<span class="ident">create_device</span>(<span class="kw-2">&amp;mut</span> <span class="ident">device</span>).<span class="ident">unwrap_or_else</span>(<span class="op">|</span><span class="kw">_</span><span class="op">|</span> {
    <span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">any</span>(<span class="ident">target_arch</span> <span class="op">=</span> <span class="string">&quot;x86&quot;</span>, <span class="ident">target_arch</span> <span class="op">=</span> <span class="string">&quot;x86_64&quot;</span>))]</span>
    <span class="macro">panic!</span>(<span class="string">&quot;Cannot create VFIO device.&quot;</span>);
    <span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">any</span>(<span class="ident">target_arch</span> <span class="op">=</span> <span class="string">&quot;arm&quot;</span>, <span class="ident">target_arch</span> <span class="op">=</span> <span class="string">&quot;aarch64&quot;</span>))]</span>
    {
        <span class="ident">device</span>.<span class="ident">type_</span> <span class="op">=</span> <span class="ident">kvm_device_type_KVM_DEV_TYPE_ARM_VGIC_V2</span>;
        <span class="ident">vm</span>.<span class="ident">create_device</span>(<span class="kw-2">&amp;mut</span> <span class="ident">device</span>)
            .<span class="ident">expect</span>(<span class="string">&quot;Cannot create vGIC device&quot;</span>)
    }
});</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.enable_cap" class="method has-srclink"><span class="rightside"><a class="srclink" href="../src/kvm_ioctls/ioctls/vm.rs.html#1288-1297">source</a></span><a href="#method.enable_cap" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.enable_cap" class="fnname">enable_cap</a>(&amp;self, cap: &amp;<a class="struct" href="../kvm_bindings/x86/bindings/struct.kvm_enable_cap.html" title="struct kvm_bindings::x86::bindings::kvm_enable_cap">kvm_enable_cap</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>, <a class="struct" href="struct.Error.html" title="struct kvm_ioctls::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Enable the specified capability as per the <code>KVM_ENABLE_CAP</code> ioctl.</p>
<p>See the documentation for <code>KVM_ENABLE_CAP</code>.</p>
<p>Returns an io::Error when the capability could not be enabled.</p>
<h5 id="arguments-22"><a href="#arguments-22">Arguments</a></h5>
<ul>
<li>kvm_enable_cap - KVM capability structure. For details check the <code>kvm_enable_cap</code>
structure in the
<a href="https://www.kernel.org/doc/Documentation/virtual/kvm/api.txt">KVM API doc</a>.</li>
</ul>
<h5 id="example-22"><a href="#example-22">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">kvm_bindings</span>;

<span class="kw">use</span> <span class="ident">kvm_bindings</span>::{<span class="ident">kvm_enable_cap</span>, <span class="ident">KVM_CAP_SPLIT_IRQCHIP</span>};

<span class="kw">let</span> <span class="ident">kvm</span> <span class="op">=</span> <span class="ident">Kvm::new</span>().<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">vm</span> <span class="op">=</span> <span class="ident">kvm</span>.<span class="ident">create_vm</span>().<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">cap</span>: <span class="ident">kvm_enable_cap</span> <span class="op">=</span> <span class="ident">Default::default</span>();
<span class="comment">// This example cannot enable an arm/aarch64 capability since there</span>
<span class="comment">// is no capability available for these architectures.</span>
<span class="kw">if</span> <span class="macro">cfg!</span>(<span class="ident">target_arch</span> <span class="op">=</span> <span class="string">&quot;x86&quot;</span>) <span class="op">|</span><span class="op">|</span> <span class="macro">cfg!</span>(<span class="ident">target_arch</span> <span class="op">=</span> <span class="string">&quot;x86_64&quot;</span>) {
    <span class="ident">cap</span>.<span class="ident">cap</span> <span class="op">=</span> <span class="ident">KVM_CAP_SPLIT_IRQCHIP</span>;
    <span class="comment">// As per the KVM documentation, KVM_CAP_SPLIT_IRQCHIP only emulates</span>
    <span class="comment">// the local APIC in kernel, expecting that a userspace IOAPIC will</span>
    <span class="comment">// be implemented by the VMM.</span>
    <span class="comment">// Along with this capability, the user needs to specify the number</span>
    <span class="comment">// of pins reserved for the userspace IOAPIC. This number needs to be</span>
    <span class="comment">// provided through the first argument of the capability structure, as</span>
    <span class="comment">// specified in KVM documentation:</span>
    <span class="comment">//     args[0] - number of routes reserved for userspace IOAPICs</span>
    <span class="comment">//</span>
    <span class="comment">// Because an IOAPIC supports 24 pins, that&#39;s the reason why this test</span>
    <span class="comment">// picked this number as reference.</span>
    <span class="ident">cap</span>.<span class="ident">args</span>[<span class="number">0</span>] <span class="op">=</span> <span class="number">24</span>;
    <span class="ident">vm</span>.<span class="ident">enable_cap</span>(<span class="kw-2">&amp;</span><span class="ident">cap</span>).<span class="ident">unwrap</span>();
}</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.run_size" class="method has-srclink"><span class="rightside"><a class="srclink" href="../src/kvm_ioctls/ioctls/vm.rs.html#1300-1302">source</a></span><a href="#method.run_size" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.run_size" class="fnname">run_size</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Get the <code>kvm_run</code> size.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.check_extension" class="method has-srclink"><span class="rightside"><a class="srclink" href="../src/kvm_ioctls/ioctls/vm.rs.html#1333-1335">source</a></span><a href="#method.check_extension" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.check_extension" class="fnname">check_extension</a>(&amp;self, c: <a class="enum" href="enum.Cap.html" title="enum kvm_ioctls::Cap">Cap</a>) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Checks if a particular <code>Cap</code> is available.</p>
<p>Returns true if the capability is supported and false otherwise.
See the documentation for <code>KVM_CHECK_EXTENSION</code>.</p>
<h5 id="arguments-23"><a href="#arguments-23">Arguments</a></h5>
<ul>
<li><code>c</code> - VM capability to check.</li>
</ul>
<h5 id="example-23"><a href="#example-23">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">kvm_ioctls::Cap</span>;

<span class="kw">let</span> <span class="ident">kvm</span> <span class="op">=</span> <span class="ident">Kvm::new</span>().<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">vm</span> <span class="op">=</span> <span class="ident">kvm</span>.<span class="ident">create_vm</span>().<span class="ident">unwrap</span>();
<span class="comment">// Check if `KVM_CAP_MP_STATE` is supported.</span>
<span class="macro">assert!</span>(<span class="ident">vm</span>.<span class="ident">check_extension</span>(<span class="ident">Cap::MpState</span>));</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.encrypt_op" class="method has-srclink"><span class="rightside"><a class="srclink" href="../src/kvm_ioctls/ioctls/vm.rs.html#1374-1381">source</a></span><a href="#method.encrypt_op" class="anchor"></a><h4 class="code-header">pub unsafe fn <a href="#method.encrypt_op" class="fnname">encrypt_op</a>&lt;T&gt;(&amp;self, op: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.pointer.html">*mut T</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>, <a class="struct" href="struct.Error.html" title="struct kvm_ioctls::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Issues platform-specific memory encryption commands to manage encrypted VMs if
the platform supports creating those encrypted VMs.</p>
<p>Currently, this ioctl is used for issuing Secure Encrypted Virtualization
(SEV) commands on AMD Processors.</p>
<p>See the documentation for <code>KVM_MEMORY_ENCRYPT_OP</code> in the
<a href="https://www.kernel.org/doc/Documentation/virtual/kvm/api.txt">KVM API doc</a>.</p>
<p>For SEV-specific functionality, prefer safe wrapper:</p>
<ul>
<li><a href="struct.VmFd.html#method.encrypt_op_sev"><code>encrypt_op_sev</code></a></li>
</ul>
<h5 id="safety-3"><a href="#safety-3">Safety</a></h5>
<p>This function is unsafe because there is no guarantee <code>T</code> is valid in this context, how
much data kernel will read from memory and where it will write data on error.</p>
<h5 id="arguments-24"><a href="#arguments-24">Arguments</a></h5>
<ul>
<li><code>op</code> - an opaque platform specific structure.</li>
</ul>
<h5 id="example-24"><a href="#example-24">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">kvm_bindings::bindings::kvm_sev_cmd</span>;

<span class="kw">let</span> <span class="ident">kvm</span> <span class="op">=</span> <span class="ident">Kvm::new</span>().<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">vm</span> <span class="op">=</span> <span class="ident">kvm</span>.<span class="ident">create_vm</span>().<span class="ident">unwrap</span>();

<span class="comment">// Initialize the SEV platform context.</span>
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">init</span>: <span class="ident">kvm_sev_cmd</span> <span class="op">=</span> <span class="ident">Default::default</span>();
<span class="kw">unsafe</span> { <span class="ident">vm</span>.<span class="ident">encrypt_op</span>(<span class="kw-2">&amp;mut</span> <span class="ident">init</span>).<span class="ident">unwrap</span>() };</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.encrypt_op_sev" class="method has-srclink"><span class="rightside"><a class="srclink" href="../src/kvm_ioctls/ioctls/vm.rs.html#1416-1420">source</a></span><a href="#method.encrypt_op_sev" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.encrypt_op_sev" class="fnname">encrypt_op_sev</a>(&amp;self, op: &amp;mut <a class="struct" href="../kvm_bindings/x86/bindings/struct.kvm_sev_cmd.html" title="struct kvm_bindings::x86::bindings::kvm_sev_cmd">kvm_sev_cmd</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>, <a class="struct" href="struct.Error.html" title="struct kvm_ioctls::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Issue common lifecycle events of SEV guests, such as launching, running, snapshotting,
migrating and decommissioning via <code>KVM_MEMORY_ENCRYPT_OP</code> ioctl.</p>
<p>Kernel documentation states that this ioctl can be used for testing whether SEV is enabled
by sending <code>NULL</code>. To do that, pass <a href="https://doc.rust-lang.org/nightly/core/ptr/fn.null_mut.html"><code>std::ptr::null_mut</code></a> to <a href="struct.VmFd.html#method.encrypt_op"><code>encrypt_op</code></a>.</p>
<p>See the documentation for Secure Encrypted Virtualization (SEV).</p>
<h5 id="arguments-25"><a href="#arguments-25">Arguments</a></h5>
<ul>
<li><code>op</code> - SEV-specific structure. For details check the
<a href="https://www.kernel.org/doc/Documentation/virtual/kvm/amd-memory-encryption.rst">Secure Encrypted Virtualization (SEV) doc</a>.</li>
</ul>
<h5 id="example-25"><a href="#example-25">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">kvm_bindings::bindings::kvm_sev_cmd</span>;

<span class="kw">let</span> <span class="ident">kvm</span> <span class="op">=</span> <span class="ident">Kvm::new</span>().<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">vm</span> <span class="op">=</span> <span class="ident">kvm</span>.<span class="ident">create_vm</span>().<span class="ident">unwrap</span>();

<span class="comment">// Check whether SEV is enabled, optional.</span>
<span class="macro">assert!</span>(<span class="kw">unsafe</span> { <span class="ident">vm</span>.<span class="ident">encrypt_op</span>(<span class="ident">null_mut</span>() <span class="kw">as</span> <span class="kw-2">*mut</span> <span class="ident">c_void</span>) }.<span class="ident">is_ok</span>());

<span class="comment">// Initialize the SEV platform context.</span>
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">init</span>: <span class="ident">kvm_sev_cmd</span> <span class="op">=</span> <span class="ident">Default::default</span>();
<span class="ident">vm</span>.<span class="ident">encrypt_op_sev</span>(<span class="kw-2">&amp;mut</span> <span class="ident">init</span>).<span class="ident">unwrap</span>();</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.register_enc_memory_region" class="method has-srclink"><span class="rightside"><a class="srclink" href="../src/kvm_ioctls/ioctls/vm.rs.html#1486-1495">source</a></span><a href="#method.register_enc_memory_region" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.register_enc_memory_region" class="fnname">register_enc_memory_region</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;memory_region: &amp;<a class="struct" href="../kvm_bindings/x86/bindings/struct.kvm_enc_region.html" title="struct kvm_bindings::x86::bindings::kvm_enc_region">kvm_enc_region</a><br>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>, <a class="struct" href="struct.Error.html" title="struct kvm_ioctls::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Register a guest memory region which may contain encrypted data.</p>
<p>It is used in the SEV-enabled guest.</p>
<p>See the documentation for <code>KVM_MEMORY_ENCRYPT_REG_REGION</code> in the
<a href="https://www.kernel.org/doc/Documentation/virtual/kvm/api.txt">KVM API doc</a>.</p>
<h5 id="arguments-26"><a href="#arguments-26">Arguments</a></h5>
<ul>
<li><code>memory_region</code> - Guest physical memory region.</li>
</ul>
<h5 id="example-26"><a href="#example-26">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">kvm_bindings::bindings</span>::{<span class="ident">kvm_enc_region</span>, <span class="ident">kvm_sev_cmd</span>, <span class="ident">kvm_sev_launch_start</span>, <span class="ident">sev_cmd_id_KVM_SEV_LAUNCH_START</span>};
<span class="kw">use</span> <span class="ident">libc</span>;

<span class="kw">let</span> <span class="ident">kvm</span> <span class="op">=</span> <span class="ident">Kvm::new</span>().<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">vm</span> <span class="op">=</span> <span class="ident">kvm</span>.<span class="ident">create_vm</span>().<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">sev</span> <span class="op">=</span> <span class="ident">OpenOptions::new</span>()
    .<span class="ident">read</span>(<span class="bool-val">true</span>)
    .<span class="ident">write</span>(<span class="bool-val">true</span>)
    .<span class="ident">open</span>(<span class="string">&quot;/dev/sev&quot;</span>)
    .<span class="ident">unwrap</span>();

<span class="comment">// Initialize the SEV platform context.</span>
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">init</span>: <span class="ident">kvm_sev_cmd</span> <span class="op">=</span> <span class="ident">Default::default</span>();
<span class="macro">assert!</span>(<span class="ident">vm</span>.<span class="ident">encrypt_op_sev</span>(<span class="kw-2">&amp;mut</span> <span class="ident">init</span>).<span class="ident">is_ok</span>());

<span class="comment">// Create the memory encryption context.</span>
<span class="kw">let</span> <span class="ident">start_data</span>: <span class="ident">kvm_sev_launch_start</span> <span class="op">=</span> <span class="ident">Default::default</span>();
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">start</span> <span class="op">=</span> <span class="ident">kvm_sev_cmd</span> {
    <span class="ident">id</span>: <span class="ident">sev_cmd_id_KVM_SEV_LAUNCH_START</span>,
    <span class="ident">data</span>: <span class="kw-2">&amp;</span><span class="ident">start_data</span> <span class="kw">as</span> <span class="kw-2">*const</span> <span class="ident">kvm_sev_launch_start</span> <span class="kw">as</span> <span class="kw">_</span>,
    <span class="ident">sev_fd</span>: <span class="ident">sev</span>.<span class="ident">as_raw_fd</span>() <span class="kw">as</span> <span class="kw">_</span>,
    ..<span class="ident">Default::default</span>()
};
<span class="macro">assert!</span>(<span class="ident">vm</span>.<span class="ident">encrypt_op_sev</span>(<span class="kw-2">&amp;mut</span> <span class="ident">start</span>).<span class="ident">is_ok</span>());

<span class="kw">let</span> <span class="ident">addr</span> <span class="op">=</span> <span class="kw">unsafe</span> {
    <span class="ident">libc::mmap</span>(
        <span class="ident">null_mut</span>(),
        <span class="number">4096</span>,
        <span class="ident">libc::PROT_READ</span> <span class="op">|</span> <span class="ident">libc::PROT_WRITE</span>,
        <span class="ident">libc::MAP_PRIVATE</span> <span class="op">|</span> <span class="ident">libc::MAP_ANONYMOUS</span>,
        <span class="op">-</span><span class="number">1</span>,
        <span class="number">0</span>,
    )
};
<span class="macro">assert_ne!</span>(<span class="ident">addr</span>, <span class="ident">libc::MAP_FAILED</span>);

<span class="kw">let</span> <span class="ident">memory_region</span> <span class="op">=</span> <span class="ident">kvm_enc_region</span> {
    <span class="ident">addr</span>: <span class="ident">addr</span> <span class="kw">as</span> <span class="kw">_</span>,
    <span class="ident">size</span>: <span class="number">4096</span>,
};
<span class="ident">vm</span>.<span class="ident">register_enc_memory_region</span>(<span class="kw-2">&amp;</span><span class="ident">memory_region</span>).<span class="ident">unwrap</span>();</code></pre></div>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.unregister_enc_memory_region" class="method has-srclink"><span class="rightside"><a class="srclink" href="../src/kvm_ioctls/ioctls/vm.rs.html#1563-1572">source</a></span><a href="#method.unregister_enc_memory_region" class="anchor"></a><h4 class="code-header">pub fn <a href="#method.unregister_enc_memory_region" class="fnname">unregister_enc_memory_region</a>(<br>&nbsp;&nbsp;&nbsp;&nbsp;&amp;self, <br>&nbsp;&nbsp;&nbsp;&nbsp;memory_region: &amp;<a class="struct" href="../kvm_bindings/x86/bindings/struct.kvm_enc_region.html" title="struct kvm_bindings::x86::bindings::kvm_enc_region">kvm_enc_region</a><br>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>, <a class="struct" href="struct.Error.html" title="struct kvm_ioctls::Error">Error</a>&gt;</h4></section></summary><div class="docblock"><p>Unregister a guest memory region registered with
<a href="struct.VmFd.html#method.register_enc_memory_region"><code>register_enc_memory_region</code></a>.</p>
<p>It is used in the SEV-enabled guest.</p>
<p>See the documentation for <code>KVM_MEMORY_ENCRYPT_UNREG_REGION</code> in the
<a href="https://www.kernel.org/doc/Documentation/virtual/kvm/api.txt">KVM API doc</a>.</p>
<h5 id="arguments-27"><a href="#arguments-27">Arguments</a></h5>
<ul>
<li><code>memory_region</code> - Guest physical memory region.</li>
</ul>
<h5 id="example-27"><a href="#example-27">Example</a></h5>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">kvm_bindings::bindings</span>::{<span class="ident">kvm_enc_region</span>, <span class="ident">kvm_sev_cmd</span>, <span class="ident">kvm_sev_launch_start</span>, <span class="ident">sev_cmd_id_KVM_SEV_LAUNCH_START</span>};
<span class="kw">use</span> <span class="ident">libc</span>;

<span class="kw">let</span> <span class="ident">kvm</span> <span class="op">=</span> <span class="ident">Kvm::new</span>().<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">vm</span> <span class="op">=</span> <span class="ident">kvm</span>.<span class="ident">create_vm</span>().<span class="ident">unwrap</span>();
<span class="kw">let</span> <span class="ident">sev</span> <span class="op">=</span> <span class="ident">OpenOptions::new</span>()
    .<span class="ident">read</span>(<span class="bool-val">true</span>)
    .<span class="ident">write</span>(<span class="bool-val">true</span>)
    .<span class="ident">open</span>(<span class="string">&quot;/dev/sev&quot;</span>)
    .<span class="ident">unwrap</span>();

<span class="comment">// Initialize the SEV platform context.</span>
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">init</span>: <span class="ident">kvm_sev_cmd</span> <span class="op">=</span> <span class="ident">Default::default</span>();
<span class="macro">assert!</span>(<span class="ident">vm</span>.<span class="ident">encrypt_op_sev</span>(<span class="kw-2">&amp;mut</span> <span class="ident">init</span>).<span class="ident">is_ok</span>());

<span class="comment">// Create the memory encryption context.</span>
<span class="kw">let</span> <span class="ident">start_data</span>: <span class="ident">kvm_sev_launch_start</span> <span class="op">=</span> <span class="ident">Default::default</span>();
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">start</span> <span class="op">=</span> <span class="ident">kvm_sev_cmd</span> {
    <span class="ident">id</span>: <span class="ident">sev_cmd_id_KVM_SEV_LAUNCH_START</span>,
    <span class="ident">data</span>: <span class="kw-2">&amp;</span><span class="ident">start_data</span> <span class="kw">as</span> <span class="kw-2">*const</span> <span class="ident">kvm_sev_launch_start</span> <span class="kw">as</span> <span class="kw">_</span>,
    <span class="ident">sev_fd</span>: <span class="ident">sev</span>.<span class="ident">as_raw_fd</span>() <span class="kw">as</span> <span class="kw">_</span>,
    ..<span class="ident">Default::default</span>()
};
<span class="macro">assert!</span>(<span class="ident">vm</span>.<span class="ident">encrypt_op_sev</span>(<span class="kw-2">&amp;mut</span> <span class="ident">start</span>).<span class="ident">is_ok</span>());

<span class="kw">let</span> <span class="ident">addr</span> <span class="op">=</span> <span class="kw">unsafe</span> {
    <span class="ident">libc::mmap</span>(
        <span class="ident">null_mut</span>(),
        <span class="number">4096</span>,
        <span class="ident">libc::PROT_READ</span> <span class="op">|</span> <span class="ident">libc::PROT_WRITE</span>,
        <span class="ident">libc::MAP_PRIVATE</span> <span class="op">|</span> <span class="ident">libc::MAP_ANONYMOUS</span>,
        <span class="op">-</span><span class="number">1</span>,
        <span class="number">0</span>,
    )
};
<span class="macro">assert_ne!</span>(<span class="ident">addr</span>, <span class="ident">libc::MAP_FAILED</span>);

<span class="kw">let</span> <span class="ident">memory_region</span> <span class="op">=</span> <span class="ident">kvm_enc_region</span> {
    <span class="ident">addr</span>: <span class="ident">addr</span> <span class="kw">as</span> <span class="kw">_</span>,
    <span class="ident">size</span>: <span class="number">4096</span>,
};
<span class="ident">vm</span>.<span class="ident">register_enc_memory_region</span>(<span class="kw-2">&amp;</span><span class="ident">memory_region</span>).<span class="ident">unwrap</span>();
<span class="ident">vm</span>.<span class="ident">unregister_enc_memory_region</span>(<span class="kw-2">&amp;</span><span class="ident">memory_region</span>).<span class="ident">unwrap</span>();</code></pre></div>
</div></details></div></details></div><h2 id="trait-implementations" class="small-section-header">Trait Implementations<a href="#trait-implementations" class="anchor"></a></h2><div id="trait-implementations-list"><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-AsRawFd" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../src/kvm_ioctls/ioctls/vm.rs.html#1584-1588">source</a></span><a href="#impl-AsRawFd" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/std/os/fd/raw/trait.AsRawFd.html" title="trait std::os::fd::raw::AsRawFd">AsRawFd</a> for <a class="struct" href="struct.VmFd.html" title="struct kvm_ioctls::VmFd">VmFd</a></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.as_raw_fd" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../src/kvm_ioctls/ioctls/vm.rs.html#1585-1587">source</a></span><a href="#method.as_raw_fd" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/std/os/fd/raw/trait.AsRawFd.html#tymethod.as_raw_fd" class="fnname">as_raw_fd</a>(&amp;self) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/std/os/fd/raw/type.RawFd.html" title="type std::os::fd::raw::RawFd">RawFd</a></h4></section></summary><div class='docblock'><p>Extracts the raw file descriptor. <a href="https://doc.rust-lang.org/nightly/std/os/fd/raw/trait.AsRawFd.html#tymethod.as_raw_fd">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><section id="impl-Debug" class="impl has-srclink"><span class="rightside"><a class="srclink" href="../src/kvm_ioctls/ioctls/vm.rs.html#54">source</a></span><a href="#impl-Debug" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="struct" href="struct.VmFd.html" title="struct kvm_ioctls::VmFd">VmFd</a></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="../src/kvm_ioctls/ioctls/vm.rs.html#54">source</a></span><a href="#method.fmt" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt" class="fnname">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'><p>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></p>
</div></details></div></details></div><h2 id="synthetic-implementations" class="small-section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor"></a></h2><div id="synthetic-implementations-list"><section id="impl-RefUnwindSafe" class="impl has-srclink"><a href="#impl-RefUnwindSafe" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.VmFd.html" title="struct kvm_ioctls::VmFd">VmFd</a></h3></section><section id="impl-Send" class="impl has-srclink"><a href="#impl-Send" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.VmFd.html" title="struct kvm_ioctls::VmFd">VmFd</a></h3></section><section id="impl-Sync" class="impl has-srclink"><a href="#impl-Sync" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.VmFd.html" title="struct kvm_ioctls::VmFd">VmFd</a></h3></section><section id="impl-Unpin" class="impl has-srclink"><a href="#impl-Unpin" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.VmFd.html" title="struct kvm_ioctls::VmFd">VmFd</a></h3></section><section id="impl-UnwindSafe" class="impl has-srclink"><a href="#impl-UnwindSafe" class="anchor"></a><h3 class="code-header in-band">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.VmFd.html" title="struct kvm_ioctls::VmFd">VmFd</a></h3></section></div><h2 id="blanket-implementations" class="small-section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor"></a></h2><div id="blanket-implementations-list"><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-Any" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#132-136">source</a></span><a href="#impl-Any" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#133">source</a></span><a href="#method.type_id" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id" class="fnname">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'><p>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#209-214">source</a></span><a href="#impl-Borrow%3CT%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/91522" title="Tracking issue for const_borrow">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#211">source</a></span><a href="#method.borrow" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow" class="fnname">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>T</h4></section></summary><div class='docblock'><p>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#218-222">source</a></span><a href="#impl-BorrowMut%3CT%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/91522" title="Tracking issue for const_borrow">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#219">source</a></span><a href="#method.borrow_mut" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fnname">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut </a>T</h4></section></summary><div class='docblock'><p>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-From%3CT%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#554-559">source</a></span><a href="#impl-From%3CT%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.from" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#556">source</a></span><a href="#method.from" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from" class="fnname">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#538-549">source</a></span><a href="#impl-Into%3CU%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle method-toggle" open><summary><section id="method.into" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#546">source</a></span><a href="#method.into" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html#tymethod.into" class="fnname">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#595-604">source</a></span><a href="#impl-TryFrom%3CU%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Error" class="type trait-impl has-srclink"><a href="#associatedtype.Error" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/nightly/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#601">source</a></span><a href="#method.try_from" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#tymethod.try_from" class="fnname">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details><details class="rustdoc-toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E" class="impl has-srclink"><span class="rightside"><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#580-589">source</a></span><a href="#impl-TryInto%3CU%3E" class="anchor"></a><h3 class="code-header in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,&nbsp;</span></h3></section></summary><div class="impl-items"><details class="rustdoc-toggle" open><summary><section id="associatedtype.Error-1" class="type trait-impl has-srclink"><a href="#associatedtype.Error-1" class="anchor"></a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div></details><details class="rustdoc-toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl has-srclink"><span class="rightside"><span class="since" title="const unstable">const: <a href="https://github.com/rust-lang/rust/issues/88674" title="Tracking issue for const_convert">unstable</a></span> · <a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#586">source</a></span><a href="#method.try_into" class="anchor"></a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#tymethod.try_into" class="fnname">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'><p>Performs the conversion.</p>
</div></details></div></details></div></section><section id="search" class="content hidden"></section></div></main><div id="rustdoc-vars" data-root-path="../" data-current-crate="kvm_ioctls" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.61.0-nightly (285fa7ecd 2022-03-14)" ></div>
</body></html>